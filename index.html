<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>CS 184 Final Report - Exploring Non-Photorealistic Rendering</title>
    <style>
        /* Basic styling adapted from the example */
        body {
            font-family: sans-serif;
            padding: 20px;
            line-height: 1.6;
            max-width: 900px; /* Limit width for readability */
            margin: 20px auto; /* Center the content */
        }

        h1, h2, h3 {
            margin-bottom: 10px;
            color: #333;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
        }

        h2 {
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            margin-top: 30px;
        }

        p {
            margin-bottom: 15px;
        }

        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }

        .media-container {
            margin-bottom: 25px;
            text-align: center; /* Center images/videos */
        }

        .media-container img, .media-container video, .media-container iframe {
             max-width: 90%; /* Prevent large media from overflowing */
             height: auto;
             margin: 10px auto;
             display: block;
             border: 1px solid #ddd; /* Optional border */
             box-shadow: 2px 2px 5px rgba(0,0,0,0.1); /* Optional shadow */
        }

        .caption {
            font-style: italic;
            color: #555;
            margin-top: 5px;
            text-align: center;
            font-size: 0.9em;
        }

        .contributions ul {
            list-style: none;
            padding: 0;
        }
        .contributions li {
            margin-bottom: 15px; /* Increased spacing */
            padding-left: 10px;
            border-left: 3px solid #ccc; /* Add a visual indicator */
        }
        .contributions strong {
            display: block; /* Make name appear on its own line */
            margin-bottom: 5px;
        }

        .references ul {
            list-style: disc;
            padding-left: 20px;
        }
        .references li {
            margin-bottom: 8px;
        }

    </style>
    </head>
<body>

    <h1>Exploring Non-Photorealistic Rendering</h1>

    <p style="text-align: center;"><strong>Team Members:</strong> Minjae Kwak, Zixun Wang, Shashwat Bansal, Jaymes Ryan Garbe</p>

    <h2>Abstract</h2>
    <p>
      This project explores the domain of Non-Photorealistic Rendering (NPR) by developing an interactive 3D rendering application. Focusing on artistic expression over strict realism, we implemented several variations of toon/cel shading using OpenGL and GLSL shaders, leveraging multiple light sources for added complexity. The application allows users to load OBJ models, view them with distinct stylized appearances including basic toon shading, colored variations, depth-influenced "toon chroma," and patterned "toon polka" effects, and interactively rotate and zoom the models using mouse controls. While our initial proposal envisioned exploring broader NPR styles and comparisons, we focused our efforts on building a robust OpenGL framework and investigating the versatility within toon shading techniques via rasterization, providing a foundation for viewing diverse stylized 3D graphics.
    </p>

    <h2>Technical Approach</h2>
    <p>
        Our technical approach centered on creating a flexible testbed for NPR shaders using standard C++ and OpenGL. We utilized several libraries to handle windowing, OpenGL extensions, mathematics, and model loading. The core components of our system include the application framework, model loading pipeline, shader implementation, and interaction controls.
    </p>

    <h3>Framework and Libraries</h3>
    <p>
        We developed a standalone C++ application. The core framework relies on:
        <ul>
            <li><b>GLFW:</b> For creating and managing the OpenGL context and window, and handling user input (keyboard, mouse).</li>
            <li><b>GLEW:</b> To manage OpenGL extensions, ensuring access to necessary modern OpenGL functions across different platforms.</li>
            <li><b>GLM:</b> For handling vector and matrix operations essential for 3D graphics transformations (model, view, projection matrices).</li>
        </ul>
        This setup provides a standard, cross-platform base for rendering 3D scenes with custom shaders. The build process was managed using CMake (`CMakeLists.txt`) which handled finding dependencies and compiling the application.
    </p>

    <h3>Model Loading</h3>
    <p>
        To render 3D models, we integrated the `tinyobjloader` library (`tiny_obj_loader.h`). Our `loadObjModel` function parses `.obj` files specified via command-line arguments or uses a default path (`teapot.obj`). This function extracts vertex positions and normals from the OBJ file. It handles triangulation implicitly by iterating through faces and processing only triangles . To optimize rendering and handle vertices shared by multiple faces (with potentially different normals or texture coordinates), we implemented a vertex de-duplication mechanism . It uses an `std::unordered_map` to store unique combinations of vertex/normal indices, ensuring that identical vertices are stored only once in the final vertex buffer, while generating the correct element indices for drawing.
    </p>

    <h3>Shader Implementation</h3>
    <p>
      We implemented a custom shader system encapsulated in a `Shader` class (`shader.h`, `shader.cpp`), handling GLSL compilation, linking, and uniform setting. Our core exploration focused on variations of toon shading, all supporting multiple light sources whose contributions are typically summed before quantization. The key variations include:
  </p>
  <ul>
    <li>
      <b>Basic Toon Shading (greyscale):</b><br/>
      <p>Defined in <code>shaders/toon.vert</code> and <code>shaders/toon.frag</code>. This implements the fundamental toon effect by quantizing the diffuse lighting calculation. The dot product between the surface normal and the light direction is calculated, clamped, and then mapped to a few discrete intensity levels using conditional logic or step functions. This creates the characteristic hard-edged shadows and flat greyscale bands, while the <code>normalMatrix</code> ensures correct normal transformation.
    </li>
  
    <li>
      <b>Thermal, 5-Tone Palette, Best:</b><br/>
      <p><strong>Thermal:</strong> In <code>shaders/toon_thermal.frag</code>, you quantize the usual diffuse term (<code>diff = max(dot(norm, lightDir), 0.0)</code>) into a handful of ranges (e.g. 0–0.2, 0.2–0.4, …). Each range is then mapped—via a small <code>vec3</code> array or 1D texture lookup—to a classic heat-map gradient (blue → cyan → green → yellow → red). You combine that ramp color with a base ambient term and your object color to give a warm-to-hot feel to each band.</p>
      <p><strong>5-Tone Palette:</strong> See <code>shaders/toon_5_tones.frag</code>. After computing <code>diff</code>, the shader uses <code>floor()</code> and <code>mod()</code> to index into an array of exactly five chosen colors (e.g. purple, blue, cyan, green, yellow). The bands repeat over successive lighting ranges, producing a bold, cyclical color effect that’s perfect for stylized visuals.</p>
      <p><strong>“Best” Stylized Glow:</strong> In <code>shaders/toon_best.frag</code>, the diffuse term is split into four hard bands—deep shadow, mid-blue, cool highlight, warm gold—via an <code>if/else</code> ladder. After combining with ambient and object color, a reverse “glow” (driven by <code>1.0 – diff</code>) tints shadowed regions in soft purple, adding painterly rim and shadow glow in a single pass.</p>
    </li>
  
    <li>
      <b>Polka Dots, Stipple:</b><br/>
      <p><strong>Polka Dots:</strong> Implemented in <code>shaders/polka_dot.frag</code>, this shader tiles the surface into cells using <code>fract()</code> on UV or world-space coordinates. Within each cell it draws a perfect circle (via a simple distance function) at the center, coloring it by hashing the cell index into a small palette. The background of each cell remains a flat complement color, yielding a uniform grid of colored dots.</p>
      <p><strong>Stipple:</strong> See <code>shaders/stipple.frag</code>. The cells are the same, but each dot’s center is jittered by a <code>rand()</code> function for a more organic look. Dot radius is interpolated between two sizes based on lighting (<code>mix()</code>), and <code>smoothstep()</code> gives the dot edge a soft falloff—mimicking hand-drawn stippling in dark and light regions.</p>
    </li>
  
    <li>
      <b>Notebook, Sine-Wave:</b><br/>
      <p><strong>Notebook:</strong> In <code>shaders/notebook.frag</code>, the surface is treated as lined paper. You compute <code>yPos = fs_in.FragPos.y + time*smallSpeed</code>, then apply <code>sin(yPos * lineFreq)</code> and a <code>smoothstep()</code> threshold to draw crisp horizontal lines. A vertical margin line (at X = constant) is added with another <code>smoothstep()</code>, all over a white base.</p>
      <p><strong>Sine-Wave Bands:</strong> See <code>shaders/sine_waves.frag</code>. Here, each fragment’s Y is offset by <code>sin(fs_in.FragPos.x * waveFreq + time)</code>. You then compute <code>bandPos = fract((yOffset) * bandCount)</code>, carve out a sharp line with <code>smoothstep()</code>, and fade above it for a flowing wave pattern. A uniform wave color is blended over white for a continuous, undulating band effect.</p>
    </li>
  
    <li>
      <b>Chroma:</b><br/>
      <p>Implemented in <code>shaders/chroma.frag</code>. First, you take the basic <code>diff</code> and perturb it per channel: for example, <code>diffR = diff + sin(depth*freqR)</code>, <code>diffG = diff + sin(depth*freqG + phase)</code>, and <code>diffB = diff + sin(depth*freqB + phase*2)</code>. Each is then clamped and quantized, creating slight hue shifts per channel that emphasize depth.</p>
      <p>Additionally, you can map world-space Z (camera depth) through a rainbow palette texture (1D lookup), then blend that result with your quantized bands—combining depth-based chroma shifts with classic toon steps for a vivid, form-accentuating effect.</p>
    </li>
  
    <li>
      <b>Gulp:</b><br/>
      <p>See <code>shaders/guap.frag</code>. This overlay uses a repeating equilateral-triangle grid: you compute local UV within each cell, apply a triangle-distance function to mask out the triangles, and stagger every other row by offsetting X. The pattern is static geometry in screen-space but wraps around your model.</p>
      <p>On top of that, the shader mixes two color ramps based on <code>diff</code> (or time): for shadows it leans toward a deep green, for mid-tones a soft teal, and for highlights a pale cream. This dynamic blending—combined with the triangle mask—gives a halftone-like “gulp” pattern that reacts to lighting.</p>
    </li>
  </ul>
  

  <h3>Implementation Details and Variations</h3>
  <p>
      Our final implementation evolved significantly from the initial proposal. We originally planned to explore multiple distinct NPR styles (sketch, watercolor) and compare them against Path Tracing or PBR . However, we pivoted to focus exclusively on the OpenGL rasterization pipeline and dedicated our efforts to exploring the creative possibilities *within* toon shading. This involved implementing not just a basic toon shader but also several variations (Colored, Chroma, Polka) to showcase different artistic effects achievable by modifying the core toon shading principles, often incorporating additional data like depth or screen position. Consequently, the path tracing integration, implementation of other broad NPR styles, and direct PBR/efficiency comparisons were set aside . The vertex deduplication logic remained a necessary implementation detail for efficient OBJ handling in OpenGL.
  </p>


    <h3>Problems Encountered</h3>
    <ul>
        <li><b>OBJ Loading and Normals:</b> A significant initial challenge involved correctly loading and processing OBJ files using `tinyobjloader`. We encountered issues with models that potentially had missing or incorrectly formatted vertex normal data. This required careful debugging of the loading logic (`loadObjModel`) to ensure normals were present and correctly associated with vertices, or implementing fallback behavior (e.g., using a default normal) .</li>
        <li><b>Scope Management:</b> The initial scope proposed (multiple advanced NPR styles, path tracing integration, PBR comparison) proved too ambitious for the timeframe. We had to rescale our goals during the project (as reflected in the milestone ) to focus on delivering a functional application with at least one well-implemented NPR technique.</li>
        <li><b>Shader Debugging:</b> Debugging GLSL shaders can be challenging. Identifying issues with lighting calculations, matrix transformations, or uniform variable passing required iterative testing and careful inspection of the visual output.</li>
         <li>[Add any other specific technical hurdles encountered, e.g., build issues, library integration problems, unexpected visual artifacts]</li>
    </ul>

    <h3>Lessons Learned</h3>
    <ul>
        <li><b>OpenGL/GLSL Fundamentals:</b> Gained practical experience setting up an OpenGL rendering pipeline, writing vertex and fragment shaders in GLSL, managing shader compilation/linking, and passing data (vertex attributes, uniforms) from the CPU to the GPU.</li>
        <li><b>3D Math and Transformations:</b> Reinforced understanding of essential 3D graphics concepts like model, view, and projection matrices, normal transformations, and vector operations (dot products, normalization) used in lighting calculations.</li>
        <li><b>NPR Techniques:</b> Learned the core principles behind toon/cel shading, specifically how quantizing lighting calculations can achieve a stylized, non-photorealistic look.</li>
        <li><b>OBJ File Format and Loading:</b> Gained familiarity with the structure of OBJ files and the complexities of parsing them, including handling vertex indexing, normals, and the need for vertex de-duplication for efficient rendering.</li>
        <li><b>Project Scoping:</b> Learned the importance of accurately estimating the time and effort required for different features and adjusting project scope based on progress and encountered difficulties. Starting with a smaller, achievable core goal is often more effective.</li>
        <li><b>Build Systems and Dependencies:</b> Gained experience using CMake to manage project builds and integrate external libraries like GLEW, GLFW, GLM, and tinyobjloader.</li>
    </ul>

    <h2>Results</h2>
    <p>
        Our application successfully loads OBJ models and renders them using the implemented toon/cel shader. The visual output exhibits the characteristic features of toon shading: areas of flat color with sharp transitions between lit and shadowed regions, determined by the quantized lighting calculation in the GLSL fragment shader. The shading dynamically updates based on the model's orientation relative to the defined light sources and the camera's viewpoint . Users can interactively rotate the model and zoom the camera to inspect the effect from different angles. The automatic camera orbit provides a continuous showcase of the rendered object.
    </p>
    <p>
        [Describe results of the Chromadepth Polka Dot shader here, if applicable, and include relevant media.]
    </p>

    <div class="media-container">
        <h3>Project Showcase Clip</h3>
        <p style="border: 1px dashed #ccc; padding: 20px; color: #777;">
            [Your Showcase GIF/Video Here - e.g., <br>
            <code>&lt;video controls src="videos/showcase_clip.mp4"&gt;&lt;/video&gt;</code> or <br>
            <code>&lt;img src="images/showcase_clip.gif" alt="Showcase Animation"&gt;</code>]
        </p>
        <p class="caption">Short video/animation demonstrating the final toon shader effect and interaction.</p>
    </div>

    <div class="media-container">
        <h3>Toon Shaded Teapot</h3>
         <p style="border: 1px dashed #ccc; padding: 20px; color: #777;">
            [Image of Toon Shaded Teapot - e.g., <br>
            <code>&lt;img src="images/toon_teapot.png" alt="Toon shaded teapot model"&gt;</code>]
        </p>
         <p class="caption">Example render of the Utah Teapot using our toon shader.</p>
    </div>

     <div class="media-container">
        <h3>[Result Title 2 - e.g., Different Model or Angle]</h3>
         <p style="border: 1px dashed #ccc; padding: 20px; color: #777;">
            [Another Result Image/Video Here]
        </p>
         <p class="caption">[Caption for result 2]</p>
    </div>

    <h2 class="references">References</h2>
    <ul>
        <li>Gooch, Bruce, and Amy Gooch. *Non-Photorealistic Rendering*. A K Peters/CRC Press, 2001.</li>
        <li>Rosales, M., et al. "A Survey on Non-photorealistic Rendering Approaches for Point Cloud Visualization." *Visual Informatics*, vol. 5, no. 1, 2021, pp. 49-64.</li>
        <li>Komikaze NPR. Toon Shader Pack. (Reference for desired outcome style) URL: `komikaze.nl/toon_shader_pack.html` (Link might be outdated).</li>
        <li>OpenGL Documentation: [https://www.opengl.org/](https://www.opengl.org/)</li>
        <li>GLEW (The OpenGL Extension Wrangler Library): [http://glew.sourceforge.net/](http://glew.sourceforge.net/)</li>
        <li>GLFW (An Open Source, multi-platform library for OpenGL): [https://www.glfw.org/](https://www.glfw.org/)</li>
        <li>GLM (OpenGL Mathematics): [https://glm.g-truc.net/](https://glm.g-truc.net/)</li>
        <li>TinyObjLoader: [https://github.com/tinyobjloader/tinyobjloader](https://github.com/tinyobjloader/tinyobjloader)</li>
        <li>LearnOpenGL: [https://learnopengl.com/](https://learnopengl.com/) (General tutorials and reference)</li>
        </ul>


    <h2 class="contributions">Contributions</h2>
    <ul>
        <li><strong>Minjae Kwak:</strong> [Describe specific contribution...]</li>
        <li><strong>Zixun Wang:</strong> [Describe specific contribution...]</li>
        <li><strong>Shashwat Bansal:</strong> I mostly worked on the <code>.frag</code> files, building on top of the toon shader to implement renderings like its 5-tones variant and adding reverse shading to make the entire object colored. I also implemented the spotlight/chroma shader and the polka dots shader, for the former of which I added multiple lighting sourcees to <code>main.cpp</code>..</li>
        <li><strong>Jaymes Ryan Garbe:</strong> I helped build the camera rotation mechanism to automatically keep rotating the models while keeping light sources fixed. I also helped setup the OpenGL framework.</li>
    </ul>

</body>
</html>
