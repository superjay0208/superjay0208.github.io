<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>CS 184 Final Report - Exploring Non-Photorealistic Rendering</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            line-height: 1.6;
            max-width: 900px;
            margin: 20px auto;
        }

        h1, h2, h3 {
            margin-bottom: 10px;
            color: #333;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
        }

        h2 {
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            margin-top: 30px;
        }

        p {
            margin-bottom: 15px;
        }

        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }

        .media-container {
            margin-bottom: 25px;
            text-align: center;
        }

        .media-container img, .media-container video, .media-container iframe {
             max-width: 90%;
             height: auto;
             margin: 10px auto;
             display: block;
             border: 1px solid #ddd;
             box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
        }

        .caption {
            font-style: italic;
            color: #555;
            margin-top: 5px;
            text-align: center;
            font-size: 0.9em;
        }

        .contributions ul {
            list-style: none;
            padding: 0;
        }
        .contributions li {
            margin-bottom: 15px;
            padding-left: 10px;
            border-left: 3px solid #ccc;
        }
        .contributions strong {
            display: block;
            margin-bottom: 5px;
        }

        .references ul {
            list-style: disc;
            padding-left: 20px;
        }
        .references li {
            margin-bottom: 8px;
        }

    </style>
    </head>
<body>

    <h1>Exploring Non-Photorealistic Rendering</h1>

    <p style="text-align: center;"><strong>Team Members:</strong> Minjae Kwak, Zixun Wang, Shashwat Bansal, Jaymes Ryan Garbe</p>

    <h2>Abstract</h2>
    <p>
      This project explores the domain of Non-Photorealistic Rendering (NPR) by developing an interactive 3D rendering application using OpenGL. We implemented several shaders using OpenGL and GLSL, allowing users to view any <code>.obj</code> model with distinct stylized appearances including basic toon shading, colored variations, chroma, and polka dot effects, and interactively rotate and zoom the models using mouse controls.
    </p>

    <h2>Technical Approach</h2>
    <p>
        Our technical approach centered on creating a flexible testbed for NPR shaders using standard C++ and OpenGL. We utilized several libraries to handle windowing, OpenGL extensions, mathematics, and model loading. The core components of our system include the application framework, model loading pipeline, shader implementation, and interaction controls.
    </p>

    <h3>Framework and Libraries</h3>
    <p>
        We developed a standalone C++ application. The core framework relies on:
        <ul>
            <li><b>GLFW:</b> For creating and managing the OpenGL context and window, and handling user input (keyboard, mouse).</li>
            <li><b>GLEW:</b> To manage OpenGL extensions, ensuring access to necessary modern OpenGL functions across different platforms.</li>
            <li><b>GLM:</b> For handling vector and matrix operations essential for 3D graphics transformations (model, view, projection matrices).</li>
        </ul>
        This setup provides a standard, cross-platform base for rendering 3D scenes with custom shaders. The build process was managed using CMake (`CMakeLists.txt`) which handled finding dependencies and compiling the application.
    </p>

    <h3>Model Loading</h3>
    <p>
        To render 3D models, we integrated the `tinyobjloader` library (`tiny_obj_loader.h`). Our `loadObjModel` function parses `.obj` files specified via command-line arguments. This function extracts vertex positions and normals from the OBJ file. It handles triangulation implicitly by iterating through faces and processing only triangles. To optimize rendering and handle vertices shared by multiple faces (with potentially different normals or texture coordinates), we implemented a vertex de-duplication mechanism. It uses an `std::unordered_map` to store unique combinations of vertex/normal indices, ensuring that identical vertices are stored only once in the final vertex buffer, while generating the correct element indices for drawing.
    </p>

    <h3>Shader Implementation</h3>
    <p>
      We implemented a custom shader system encapsulated in a `Shader` class (`shader.h`, `shader.cpp`), handling GLSL compilation, linking, and uniform setting. Our core exploration focused on variations of toon shading, all supporting multiple light sources whose contributions are typically summed before quantization. The key variations include:
  </p>
  <ul>
    <li>
      <b>Basic Toon Shading (greyscale):</b><br/>
      <p>Defined in <code>shaders/toon.vert</code> and <code>shaders/toon_gray.frag</code>. We implemented this grayscale toon shader by quantizing the diffuse lighting into discrete bands based on the dot product between the surface normal and light direction, combining it with a constant ambient term to produce stylized shading with sharp grayscale transitions.</p>
    </li>
  
    <li>
      <b>Thermal, 5-Tone Palette, Yellow-Blue:</b><br/>
      <p><strong>Yellow-Blue Stylized Glow:</strong> In <code>shaders/toon_best.frag</code>, the diffuse term is split into four hard bands via an <code>if/else</code> ladder. After combining with ambient and object color, a reverse “glow” (driven by <code>1.0 – diff</code>) tints shadowed regions in soft purple.</p>
      <p><strong>Thermal:</strong> In <code>shaders/toon_thermal.frag</code>, we quantize the usual diffuse term (<code>diff = max(dot(norm, lightDir), 0.0)</code>) into a handful of ranges. Each range is then mapped—via a small <code>vec3</code> array or 1D texture lookup—to a classic heat-map gradient.</p>
      <p><strong>5-Tone Palette:</strong> See <code>shaders/toon_5_tones.frag</code>. After computing <code>diff</code>, the shader indexes into an array of exactly five chosen colors. The bands repeat over successive lighting ranges.</p>
      </li>
  
    <li>
      <b>Polka Dots, Stipple:</b><br/>
      <p><strong>Polka Dots:</strong> Implemented in <code>shaders/polka_dot.frag</code>, this shader tiles the surface into cells using <code>fract()</code> on UV or world-space coordinates. Within each cell it draws a perfect circle (via a simple distance function) at the center, coloring it by hashing the cell index into a small palette randomly.</p>
      <p><strong>Stipple:</strong> See <code>shaders/stipple.frag</code>. The cells are the same, but each dot’s center is jittered by a <code>rand()</code> function for a more organic look. Dot radius is interpolated between two sizes based on lighting (<code>mix()</code>), and <code>smoothstep()</code> gives the dot edge a soft falloff—mimicking hand-drawn stippling in dark and light regions.</p>
    </li>
  
    <li>
      <b>Notebook, Sine-Wave:</b><br/>
      <p><strong>Notebook:</strong> In <code>shaders/notebook.frag</code>, the surface is treated as lined paper. We compute <code>yPos = fs_in.FragPos.y + time*smallSpeed</code>, then apply <code>sin(yPos * lineFreq)</code> and a <code>smoothstep()</code> threshold to draw crisp horizontal lines. A vertical margin line (at X = constant) is added with another <code>smoothstep()</code>, all over a white base. Lastly, the same is done once vertically for the red margin line.</p>
      <p><strong>Sine-Wave Bands:</strong> See <code>shaders/sine_waves.frag</code>. Here, each fragment’s Y is offset by <code>sin(fs_in.FragPos.x * waveFreq + time)</code>. We then compute <code>bandPos = fract((yOffset) * bandCount)</code>, carve out a sharp line with <code>smoothstep()</code>, and fade above it for a flowing wave pattern. A uniform wave color is blended over white for a continuous diminishing band effect.</p>
    </li>
  
    <li>
      <b>Chroma:</b><br/>
      <p>Implemented in <code>shaders/chroma.frag</code>. First, we take the basic <code>diff</code> and perturb it per channel: <code>diffR = diff + sin(depth*freqR)</code>, <code>diffG = diff + sin(depth*freqG + phase)</code>, and <code>diffB = diff + sin(depth*freqB + phase*2)</code>. Each is then clamped and quantized, creating slight hue shifts per channel that emphasize depth. Lastly, we moved to a vector of light sources in <code>main.cpp</code> to allow for more well-distributed lighting.</p>
    </li>
  
    <li>
      <b>Guap:</b><br/>
      <p>See <code>shaders/guap.frag</code>. This overlay uses a repeating equilateral-triangle grid: we compute local UV within each cell, apply a triangle-distance function to mask out the triangles, and stagger every other row by offsetting X. On top of that, the shader mixes two color ramps based on <code>diff</code> (or time): for shadows it leans toward a deep green, for mid-tones a soft teal, and for highlights a pale white. Due to the large number of triangles, guap suffers from heavy aliasing.</p>
    </li>
  </ul>

  <h3>Implementation Details and Variations</h3>
  <p>
      Our final implementation evolved significantly from the initial proposal. We originally planned to explore multiple distinct NPR styles (sketch, watercolor) and compare them against Path Tracing or PBR. However, we pivoted to focus exclusively on the OpenGL rasterization pipeline and dedicated our efforts to exploring the creative possibilities *within* toon shading. This involved implementing not just a basic toon shader but also several variations to showcase different artistic effects achievable by modifying the core toon shading principles, often incorporating additional data like depth or screen position. Consequently, the path tracing integration, implementation of other broad NPR styles, and direct PBR/efficiency comparisons were set aside. The vertex deduplication logic remained a necessary implementation detail for efficient OBJ handling in OpenGL.
  </p>

    <h3>Problems Encountered</h3>
    <ul>
        <li><b>OBJ Loading and Normals:</b> A significant initial challenge involved correctly loading and processing OBJ files using `tinyobjloader`. We encountered issues with models that potentially had missing or incorrectly formatted vertex normal data. This required careful debugging of the loading logic (`loadObjModel`) to ensure normals were present and correctly associated with vertices, or implementing fallback behavior (e.g., using a default normal).</li>
        <li><b>Scope Management:</b> The initial scope proposed (multiple advanced NPR styles, path tracing integration, PBR comparison) proved too ambitious for the timeframe. We had to rescale our goals during the project (as reflected in the milestone ) to focus on delivering a functional application with at least one well-implemented NPR technique.</li>
        <li><b>Shader Debugging:</b> Identifying issues with lighting calculations, texture mapping, and visual artifacts required repetitive testing and careful inspection of the visual output.</li>
         <li></li>
    </ul>

    <h3>Lessons Learned</h3>
    <ul>
        <li><b>OpenGL/GLSL Fundamentals:</b> Gained practical experience setting up an OpenGL rendering pipeline, writing vertex and fragment shaders in GLSL, managing shader compilation/linking, and passing data (vertex attributes, uniforms) from the CPU to the GPU.</li>
        <li><b>3D Math and Transformations:</b> Reinforced understanding of essential 3D graphics concepts like model, view, and projection matrices, normal transformations, and vector operations (dot products, normalization) used in lighting calculations.</li>
        <li><b>NPR Techniques:</b> Learned the core principles behind toon/cel shading, specifically how quantizing lighting calculations can achieve a stylized, non-photorealistic look.</li>
        <li><b>OBJ File Format and Loading:</b> Gained familiarity with the structure of OBJ files and the complexities of parsing them, including handling vertex indexing, normals, and the need for vertex de-duplication for efficient rendering.</li>
        <li><b>Project Scoping:</b> Learned the importance of accurately estimating the time and effort required for different features and adjusting project scope based on progress and encountered difficulties. Starting with a smaller, achievable core goal is often more effective.</li>
        <li><b>Build Systems and Dependencies:</b> Gained experience using CMake to manage project builds and integrate external libraries like GLEW, GLFW, GLM, and tinyobjloader.</li>
    </ul>

    <h2>Results</h2>
    <p>
        Our application successfully loads OBJ models and renders them using the implemented toon/cel shader. The visual output exhibits the characteristic features of toon shading: areas of flat color with sharp transitions between lit and shadowed regions, determined by the quantized lighting calculation in the GLSL fragment shader. The shading dynamically updates based on the model's orientation relative to the defined light sources and the camera's viewpoint. Users can interactively rotate the model and zoom the camera to inspect the effect from different angles. The automatic camera orbit provides a continuous showcase of the rendered object.
    </p>
    <p>
        [Describe results of the Chromadepth Polka Dot shader here, if applicable, and include relevant media.]
    </p>

    <div class="media-container">
        <h3>Project Showcase Clip</h3>
        <p style="border: 1px dashed #ccc; padding: 20px; color: #777;">
            [Our Showcase GIF/Video Here - e.g., <br>
            <code>&lt;video controls src="videos/showcase_clip.mp4"&gt;&lt;/video&gt;</code> or <br>
            <code>&lt;img src="images/showcase_clip.gif" alt="Showcase Animation"&gt;</code>]
        </p>
        <p class="caption">Short video/animation demonstrating the final toon shader effect and interaction.</p>
    </div>

    <div class="media-container">
        <h3>Toon Shaded Teapot</h3>
         <p style="border: 1px dashed #ccc; padding: 20px; color: #777;">
            [Image of Toon Shaded Teapot - e.g., <br>
            <code>&lt;img src="images/toon_teapot.png" alt="Toon shaded teapot model"&gt;</code>]
        </p>
         <p class="caption">Example render of the Utah Teapot using our toon shader.</p>
    </div>

     <div class="media-container">
        <h3>[Result Title 2 - e.g., Different Model or Angle]</h3>
         <p style="border: 1px dashed #ccc; padding: 20px; color: #777;">
            [Another Result Image/Video Here]
        </p>
         <p class="caption">[Caption for result 2]</p>
    </div>

    <h2 class="references">References</h2>
    <ul>
        <li>Gooch, Bruce, and Amy Gooch. *Non-Photorealistic Rendering*. A K Peters/CRC Press, 2001.</li>
        <li>Rosales, M., et al. "A Survey on Non-photorealistic Rendering Approaches for Point Cloud Visualization." *Visual Informatics*, vol. 5, no. 1, 2021, pp. 49-64.</li>
        <li>Komikaze NPR. Toon Shader Pack. (Reference for desired outcome style) URL: `komikaze.nl/toon_shader_pack.html` (Link might be outdated).</li>
        <li>OpenGL Documentation: [https://www.opengl.org/](https://www.opengl.org/)</li>
        <li>GLEW (The OpenGL Extension Wrangler Library): [http://glew.sourceforge.net/](http://glew.sourceforge.net/)</li>
        <li>GLFW (An Open Source, multi-platform library for OpenGL): [https://www.glfw.org/](https://www.glfw.org/)</li>
        <li>GLM (OpenGL Mathematics): [https://glm.g-truc.net/](https://glm.g-truc.net/)</li>
        <li>TinyObjLoader: [https://github.com/tinyobjloader/tinyobjloader](https://github.com/tinyobjloader/tinyobjloader)</li>
        <li>LearnOpenGL: [https://learnopengl.com/](https://learnopengl.com/) (General tutorials and reference)</li>
        </ul>


    <h2 class="contributions">Contributions</h2>
    <ul>
        <li><strong>Minjae Kwak:</strong> [Describe specific contribution...]</li>
        <li><strong>Zixun Wang:</strong> [Describe specific contribution...]</li>
        <li><strong>Shashwat Bansal:</strong> I mostly worked on the <code>.frag</code> files, building on top of the toon shader to implement renderings like its 5-tones variant and adding reverse shading to make the entire object colored. I also implemented the spotlight/chroma shader and the polka dots shader, for the former of which I added multiple lighting sourcees to <code>main.cpp</code>.</li>
        <li><strong>Jaymes Ryan Garbe:</strong> I helped build the camera rotation mechanism to automatically keep rotating the models while keeping light sources fixed. I also helped setup the OpenGL framework.</fli>
    </ul>

</body>
</html>
